<!-- Generated by SpecStory -->

# Add code for packaging (2025-07-19 18:57Z)

_**User**_

add code for packaging

---

_**Assistant**_

I'll help you add packaging code for your map locations project. Let me first examine the current project structure to understand what we're working with.


---

<details>
            <summary>Listed current directory ‚Ä¢ **6** results</summary>

| Name |
|-------|
| üìÑ `.cursorrules` |
| üìÅ `map_locations` |
| üìÑ `README.md` |
| üìÑ `passages.yaml` |
| üìÅ `.ipynb_checkpoints` |
| üìÅ `maps` |

</details>

---

<details>
            <summary>Listed directory map_locations ‚Ä¢ **1** results</summary>

| Name |
|-------|
| üìÑ `map_locations.py` |

</details>

---

Read file: map_locations/map_locations.py

---

Read file: map_locations/map_locations.py

---

Now I'll create the necessary packaging files for your Python project. Based on the project structure and the cursor rules, I'll create a comprehensive packaging setup.


---

```diff
-
+ #!/usr/bin/env python3
+ """
+ Setup script for map_locations package.
+ """
+
+ from setuptools import setup, find_packages
+ import os
+
+ # Read the README file for long description
+ def read_readme():
+     """Read README.md file for long description."""
+     readme_path = os.path.join(os.path.dirname(__file__), "README.md")
+     if os.path.exists(readme_path):
+         with open(readme_path, "r", encoding="utf-8") as f:
+             return f.read()
+     return ""
+
+ # Read requirements from requirements.txt if it exists
+ def read_requirements():
+     """Read requirements from requirements.txt file."""
+     requirements_path = os.path.join(os.path.dirname(__file__), "requirements.txt")
+     if os.path.exists(requirements_path):
+         with open(requirements_path, "r", encoding="utf-8") as f:
+             return [line.strip() for line in f if line.strip() and not line.startswith("#")]
+     return []
+
+ setup(
+     name="map-locations",
+     version="0.1.0",
+     author="Your Name",
+     author_email="your.email@example.com",
+     description="A Python library and CLI tool for mapping locations with interactive filtering and visualization capabilities",
+     long_description=read_readme(),
+     long_description_content_type="text/markdown",
+     url="https://github.com/yourusername/map-locations",
+     project_urls={
+         "Bug Reports": "https://github.com/yourusername/map-locations/issues",
+         "Source": "https://github.com/yourusername/map-locations",
+         "Documentation": "https://github.com/yourusername/map-locations#readme",
+     },
+     packages=find_packages(),
+     classifiers=[
+         "Development Status :: 3 - Alpha",
+         "Intended Audience :: Developers",
+         "Intended Audience :: Science/Research",
+         "License :: OSI Approved :: MIT License",
+         "Operating System :: OS Independent",
+         "Programming Language :: Python :: 3",
+         "Programming Language :: Python :: 3.7",
+         "Programming Language :: Python :: 3.8",
+         "Programming Language :: Python :: 3.9",
+         "Programming Language :: Python :: 3.10",
+         "Programming Language :: Python :: 3.11",
+         "Topic :: Scientific/Engineering :: GIS",
+         "Topic :: Software Development :: Libraries :: Python Modules",
+         "Topic :: Utilities",
+     ],
+     python_requires=">=3.7",
+     install_requires=read_requirements(),
+     extras_require={
+         "dev": [
+             "pytest>=6.0",
+             "pytest-cov>=2.0",
+             "black>=21.0",
+             "flake8>=3.8",
+             "mypy>=0.800",
+             "pre-commit>=2.0",
+         ],
+         "docs": [
+             "sphinx>=4.0",
+             "sphinx-rtd-theme>=1.0",
+         ],
+     },
+     entry_points={
+         "console_scripts": [
+             "map-locations=map_locations.cli:main",
+         ],
+     },
+     include_package_data=True,
+     zip_safe=False,
+     keywords="maps, locations, gis, folium, yaml, geojson, kml",
+     license="MIT",
+ )
```

---

```diff
-
+ [build-system]
+ requires = ["setuptools>=45", "wheel", "setuptools_scm[toml]>=6.2"]
+ build-backend = "setuptools.build_meta"
+
+ [project]
+ name = "map-locations"
+ dynamic = ["version"]
+ description = "A Python library and CLI tool for mapping locations with interactive filtering and visualization capabilities"
+ readme = "README.md"
+ license = {text = "MIT"}
+ authors = [
+     {name = "Your Name", email = "your.email@example.com"}
+ ]
+ maintainers = [
+     {name = "Your Name", email = "your.email@example.com"}
+ ]
+ keywords = ["maps", "locations", "gis", "folium", "yaml", "geojson", "kml"]
+ classifiers = [
+     "Development Status :: 3 - Alpha",
+     "Intended Audience :: Developers",
+     "Intended Audience :: Science/Research",
+     "License :: OSI Approved :: MIT License",
+     "Operating System :: OS Independent",
+     "Programming Language :: Python :: 3",
+     "Programming Language :: Python :: 3.7",
+     "Programming Language :: Python :: 3.8",
+     "Programming Language :: Python :: 3.9",
+     "Programming Language :: Python :: 3.10",
+     "Programming Language :: Python :: 3.11",
+     "Topic :: Scientific/Engineering :: GIS",
+     "Topic :: Software Development :: Libraries :: Python Modules",
+     "Topic :: Utilities",
+ ]
+ requires-python = ">=3.7"
+ dependencies = [
+     "folium>=0.12.0",
+     "pyyaml>=6.0",
+ ]
+
+ [project.optional-dependencies]
+ dev = [
+     "pytest>=6.0",
+     "pytest-cov>=2.0",
+     "black>=21.0",
+     "flake8>=3.8",
+     "mypy>=0.800",
+     "pre-commit>=2.0",
+ ]
+ docs = [
+     "sphinx>=4.0",
+     "sphinx-rtd-theme>=1.0",
+ ]
+
+ [project.scripts]
+ map-locations = "map_locations.cli:main"
+
+ [project.urls]
+ Homepage = "https://github.com/yourusername/map-locations"
+ Documentation = "https://github.com/yourusername/map-locations#readme"
+ Repository = "https://github.com/yourusername/map-locations"
+ "Bug Tracker" = "https://github.com/yourusername/map-locations/issues"
+
+ [tool.setuptools_scm]
+ write_to = "map_locations/_version.py"
+
+ [tool.black]
+ line-length = 88
+ target-version = ['py37']
+ include = '\.pyi?$'
+ extend-exclude = '''
+ /(
+   # directories
+   \.eggs
+   | \.git
+   | \.hg
+   | \.mypy_cache
+   | \.tox
+   | \.venv
+   | build
+   | dist
+ )/
+ '''
+
+ [tool.isort]
+ profile = "black"
+ multi_line_output = 3
+ line_length = 88
+ known_first_party = ["map_locations"]
+
+ [tool.mypy]
+ python_version = "3.7"
+ warn_return_any = true
+ warn_unused_configs = true
+ disallow_untyped_defs = true
+ disallow_incomplete_defs = true
+ check_untyped_defs = true
+ disallow_untyped_decorators = true
+ no_implicit_optional = true
+ warn_redundant_casts = true
+ warn_unused_ignores = true
+ warn_no_return = true
+ warn_unreachable = true
+ strict_equality = true
+
+ [[tool.mypy.overrides]]
+ module = [
+     "folium.*",
+     "yaml.*",
+ ]
+ ignore_missing_imports = true
+
+ [tool.pytest.ini_options]
+ minversion = "6.0"
+ addopts = "-ra -q --strict-markers --strict-config"
+ testpaths = ["tests"]
+ python_files = ["test_*.py", "*_test.py"]
+ python_classes = ["Test*"]
+ python_functions = ["test_*"]
+
+ [tool.coverage.run]
+ source = ["map_locations"]
+ omit = [
+     "*/tests/*",
+     "*/test_*",
+     "*/__pycache__/*",
+ ]
+
+ [tool.coverage.report]
+ exclude_lines = [
+     "pragma: no cover",
+     "def __repr__",
+     "if self.debug:",
+     "if settings.DEBUG",
+     "raise AssertionError",
+     "raise NotImplementedError",
+     "if 0:",
+     "if __name__ == .__main__.:",
+     "class .*\\bProtocol\\):",
+     "@(abc\\.)?abstractmethod",
+ ]
```

---

```diff
-
+ # Core dependencies for map_locations package
+ folium>=0.12.0
+ pyyaml>=6.0
+
+ # Optional dependencies for development
+ # pytest>=6.0
+ # pytest-cov>=2.0
+ # black>=21.0
+ # flake8>=3.8
+ # mypy>=0.800
+ # pre-commit>=2.0
```

---

```diff
-
+ # Include README and license files
+ include README.md
+ include LICENSE
+ include requirements.txt
+
+ # Include package data
+ recursive-include map_locations *.py
+ recursive-include map_locations *.yaml
+ recursive-include map_locations *.yml
+
+ # Include test files
+ recursive-include tests *.py
+ recursive-include tests *.yaml
+ recursive-include tests *.yml
+
+ # Include documentation
+ recursive-include docs *.md
+ recursive-include docs *.rst
+ recursive-include docs *.txt
+
+ # Exclude common files that shouldn't be included
+ global-exclude *.pyc
+ global-exclude *.pyo
+ global-exclude *.pyd
+ global-exclude __pycache__
+ global-exclude .git*
+ global-exclude .DS_Store
+ global-exclude *.so
+ global-exclude *.egg
+ global-exclude *.egg-info
+ global-exclude .pytest_cache
+ global-exclude .coverage
+ global-exclude .mypy_cache
+ global-exclude .tox
+ global-exclude .venv
+ global-exclude venv
+ global-exclude env
+ global-exclude .env
```

---

Now I need to restructure the package to follow Python packaging conventions. Let me create the proper package structure:


---

```diff
-
+ """
+ Map Locations - A Python library for mapping locations with interactive filtering and visualization.
+
+ This package provides tools for loading location data from YAML files,
+ creating interactive maps with Folium, and exporting to various formats
+ including JSON, CSV, GeoJSON, and KML.
+ """
+
+ __version__ = "0.1.0"
+ __author__ = "Your Name"
+ __email__ = "your.email@example.com"
+
+ from .map_locations import (
+     load_locations_from_yaml,
+     export_to_json,
+     export_to_csv,
+     export_to_geojson,
+     export_to_kml,
+     export_to_all_formats,
+     show_locations_grouped,
+ )
+
+ __all__ = [
+     "load_locations_from_yaml",
+     "export_to_json",
+     "export_to_csv",
+     "export_to_geojson",
+     "export_to_kml",
+     "export_to_all_formats",
+     "show_locations_grouped",
+ ]
```

---

```diff
-
+ #!/usr/bin/env python3
+ """
+ Command-line interface for map_locations package.
+ """
+
+ import argparse
+ import sys
+ from pathlib import Path
+ from typing import List, Optional
+
+ from .map_locations import (
+     load_locations_from_yaml,
+     export_to_json,
+     export_to_csv,
+     export_to_geojson,
+     export_to_kml,
+     export_to_all_formats,
+     show_locations_grouped,
+ )
+
+
+ def create_parser() -> argparse.ArgumentParser:
+     """Create and configure the argument parser."""
+     parser = argparse.ArgumentParser(
+         description="Map Locations - Interactive mapping and export tool",
+         formatter_class=argparse.RawDescriptionHelpFormatter,
+         epilog="""
+ Examples:
+   # Create an interactive map
+   map-locations map passages.yaml --output maps/passages/map.html
+
+   # Export to all formats
+   map-locations export passages.yaml --output maps/passages/passages
+
+   # Export to specific format
+   map-locations export passages.yaml --format json --output maps/passages/passages.json
+
+   # Create map grouped by type
+   map-locations map passages.yaml --group-by type --output maps/passages/map.html
+         """,
+     )
+
+     subparsers = parser.add_subparsers(dest="command", help="Available commands")
+
+     # Map command
+     map_parser = subparsers.add_parser(
+         "map", help="Create an interactive map from YAML file"
+     )
+     map_parser.add_argument(
+         "yaml_file",
+         type=str,
+         help="Path to YAML file containing location data",
+     )
+     map_parser.add_argument(
+         "--output",
+         "-o",
+         type=str,
+         default="map.html",
+         help="Output path for the HTML map (default: map.html)",
+     )
+     map_parser.add_argument(
+         "--group-by",
+         "-g",
+         type=str,
+         default="neighborhood",
+         choices=["neighborhood", "type", "date_added", "date_visited"],
+         help="Field to group markers by (default: neighborhood)",
+     )
+
+     # Export command
+     export_parser = subparsers.add_parser(
+         "export", help="Export locations to various formats"
+     )
+     export_parser.add_argument(
+         "yaml_file",
+         type=str,
+         help="Path to YAML file containing location data",
+     )
+     export_parser.add_argument(
+         "--output",
+         "-o",
+         type=str,
+         required=True,
+         help="Output path (without extension for all formats, or with extension for specific format)",
+     )
+     export_parser.add_argument(
+         "--format",
+         "-f",
+         type=str,
+         choices=["json", "csv", "geojson", "kml", "all"],
+         default="all",
+         help="Export format (default: all)",
+     )
+
+     return parser
+
+
+ def validate_yaml_file(yaml_path: str) -> None:
+     """Validate that the YAML file exists and is readable."""
+     path = Path(yaml_path)
+     if not path.exists():
+         print(f"‚ùå Error: YAML file '{yaml_path}' does not exist.")
+         sys.exit(1)
+     if not path.is_file():
+         print(f"‚ùå Error: '{yaml_path}' is not a file.")
+         sys.exit(1)
+
+
+ def handle_map_command(args: argparse.Namespace) -> None:
+     """Handle the map command."""
+     try:
+         # Load locations
+         print(f"üìÇ Loading locations from: {args.yaml_file}")
+         locations = load_locations_from_yaml(args.yaml_file)
+
+         if not locations:
+             print("‚ùå No locations found in the YAML file.")
+             sys.exit(1)
+
+         print(f"üìç Loaded {len(locations)} locations")
+
+         # Create map
+         print(f"üó∫Ô∏è Creating interactive map...")
+         show_locations_grouped(
+             locations,
+             group_by=args.group_by,
+             map_filename=args.output,
+         )
+
+         print(f"‚úÖ Map created successfully!")
+
+     except Exception as e:
+         print(f"‚ùå Error creating map: {e}")
+         sys.exit(1)
+
+
+ def handle_export_command(args: argparse.Namespace) -> None:
+     """Handle the export command."""
+     try:
+         # Load locations
+         print(f"üìÇ Loading locations from: {args.yaml_file}")
+         locations = load_locations_from_yaml(args.yaml_file)
+
+         if not locations:
+             print("‚ùå No locations found in the YAML file.")
+             sys.exit(1)
+
+         print(f"üìç Loaded {len(locations)} locations")
+
+         # Determine output path
+         output_path = Path(args.output)
+
+         if args.format == "all":
+             # Export to all formats
+             print(f"üì§ Exporting to all formats...")
+             export_to_all_formats(locations, str(output_path))
+         else:
+             # Export to specific format
+             if not output_path.suffix:
+                 output_path = output_path.with_suffix(f".{args.format}")
+
+             print(f"üì§ Exporting to {args.format.upper()} format...")
+
+             if args.format == "json":
+                 export_to_json(locations, str(output_path))
+             elif args.format == "csv":
+                 export_to_csv(locations, str(output_path))
+             elif args.format == "geojson":
+                 export_to_geojson(locations, str(output_path))
+             elif args.format == "kml":
+                 export_to_kml(locations, str(output_path))
+
+         print(f"‚úÖ Export completed successfully!")
+
+     except Exception as e:
+         print(f"‚ùå Error during export: {e}")
+         sys.exit(1)
+
+
+ def main(args: Optional[List[str]] = None) -> None:
+     """Main entry point for the CLI."""
+     parser = create_parser()
+     parsed_args = parser.parse_args(args)
+
+     if not parsed_args.command:
+         parser.print_help()
+         sys.exit(1)
+
+     # Validate YAML file
+     validate_yaml_file(parsed_args.yaml_file)
+
+     # Handle commands
+     if parsed_args.command == "map":
+         handle_map_command(parsed_args)
+     elif parsed_args.command == "export":
+         handle_export_command(parsed_args)
+     else:
+         print(f"‚ùå Unknown command: {parsed_args.command}")
+         sys.exit(1)
+
+
+ if __name__ == "__main__":
+     main()
```

---

Now I need to move the existing map_locations.py file to the correct location and update it:


---

```bash
mv map_locations/map_locations.py map_locations/core.py
```

```
(agents) (base) lavi@LT49200:~/lavi_src/map_locations$ mv map_locations/map_locations.py ma
(agents) (base) lavi@LT49200:~/lavi_src/map_locations$ mv map_locations/map_locations.py ma
p_locations/core.py
(agents) (base) lavi@LT49200:~/lavi_src/map_locations$
```

---

```diff
  __email__ = "your.email@example.com"

- from .map_locations import (
+ from .core import (
      load_locations_from_yaml,
      export_to_json,
```

---

```diff
  from typing import List, Optional

- from .map_locations import (
+ from .core import (
      load_locations_from_yaml,
      export_to_json,
```

---

Now let me create some additional packaging files:


---

```diff
-
+ MIT License
+
+ Copyright (c) 2024 Your Name
+
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+
+ The above copyright notice and this permission notice shall be included in all
+ copies or substantial portions of the Software.
+
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ SOFTWARE.
```

---

```diff
-
+ .PHONY: help install install-dev test lint format clean build publish
+
+ # Default target
+ help:
+ 	@echo "Available commands:"
+ 	@echo "  install      - Install the package in development mode"
+ 	@echo "  install-dev  - Install the package with development dependencies"
+ 	@echo "  test         - Run tests"
+ 	@echo "  lint         - Run linting checks"
+ 	@echo "  format       - Format code with black and isort"
+ 	@echo "  clean        - Clean build artifacts"
+ 	@echo "  build        - Build the package"
+ 	@echo "  publish      - Build and publish to PyPI (if configured)"
+
+ # Install the package in development mode
+ install:
+ 	pip install -e .
+
+ # Install with development dependencies
+ install-dev:
+ 	pip install -e ".[dev]"
+
+ # Run tests
+ test:
+ 	pytest tests/ -v --cov=map_locations --cov-report=term-missing
+
+ # Run linting
+ lint:
+ 	flake8 map_locations/ tests/
+ 	mypy map_locations/
+
+ # Format code
+ format:
+ 	black map_locations/ tests/
+ 	isort map_locations/ tests/
+
+ # Clean build artifacts
+ clean:
+ 	rm -rf build/
+ 	rm -rf dist/
+ 	rm -rf *.egg-info/
+ 	find . -type d -name __pycache__ -exec rm -rf {} +
+ 	find . -type f -name "*.pyc" -delete
+
+ # Build the package
+ build: clean
+ 	python -m build
+
+ # Publish to PyPI (requires proper configuration)
+ publish: build
+ 	twine upload dist/*
+
+ # Development setup
+ setup-dev: install-dev
+ 	pre-commit install
+
+ # Quick test of the CLI
+ test-cli:
+ 	python -m map_locations.cli --help
+ 	python -m map_locations.cli map --help
+ 	python -m map_locations.cli export --help
```

---

```diff
-
+ repos:
+   - repo: https://github.com/pre-commit/pre-commit-hooks
+     rev: v4.4.0
+     hooks:
+       - id: trailing-whitespace
+       - id: end-of-file-fixer
+       - id: check-yaml
+       - id: check-added-large-files
+       - id: check-merge-conflict
+       - id: debug-statements
+
+   - repo: https://github.com/psf/black
+     rev: 23.3.0
+     hooks:
+       - id: black
+         language_version: python3
+
+   - repo: https://github.com/pycqa/isort
+     rev: 5.12.0
+     hooks:
+       - id: isort
+         args: ["--profile", "black"]
+
+   - repo: https://github.com/pycqa/flake8
+     rev: 6.0.0
+     hooks:
+       - id: flake8
+         args: [--max-line-length=88, --extend-ignore=E203,W503]
+
+   - repo: https://github.com/pre-commit/mirrors-mypy
+     rev: v1.3.0
+     hooks:
+       - id: mypy
+         additional_dependencies: [types-all]
+         args: [--ignore-missing-imports]
```

---

```diff
-
+ """
+ Tests for map_locations package.
+ """
```

---

```diff
-
+ """
+ Tests for core functionality of map_locations package.
+ """
+
+ import pytest
+ import tempfile
+ import os
+ from pathlib import Path
+ from unittest.mock import patch, mock_open
+
+ from map_locations.core import (
+     load_locations_from_yaml,
+     export_to_json,
+     export_to_csv,
+     export_to_geojson,
+     export_to_kml,
+     export_to_all_formats,
+ )
+
+
+ class TestLoadLocationsFromYaml:
+     """Test loading locations from YAML files."""
+
+     def test_load_locations_valid_yaml(self):
+         """Test loading locations from valid YAML."""
+         yaml_content = """
+         locations:
+           - name: "Test Location"
+             type: "restaurant"
+             latitude: 40.7128
+             longitude: -74.0060
+             tags: ["food", "dinner"]
+             neighborhood: "Manhattan"
+             date_added: "2024-01-01"
+         """
+
+         with patch("builtins.open", mock_open(read_data=yaml_content)):
+             locations = load_locations_from_yaml("dummy.yaml")
+
+         assert len(locations) == 1
+         assert locations[0]["name"] == "Test Location"
+         assert locations[0]["type"] == "restaurant"
+         assert locations[0]["latitude"] == 40.7128
+         assert locations[0]["longitude"] == -74.0060
+         assert locations[0]["tags"] == ["food", "dinner"]
+         assert locations[0]["neighborhood"] == "Manhattan"
+         assert locations[0]["date_added"] == "2024-01-01"
+
+     def test_load_locations_empty_yaml(self):
+         """Test loading from YAML with no locations."""
+         yaml_content = "locations: []"
+
+         with patch("builtins.open", mock_open(read_data=yaml_content)):
+             locations = load_locations_from_yaml("dummy.yaml")
+
+         assert locations == []
+
+     def test_load_locations_missing_locations_key(self):
+         """Test loading from YAML without locations key."""
+         yaml_content = "other_key: value"
+
+         with patch("builtins.open", mock_open(read_data=yaml_content)):
+             locations = load_locations_from_yaml("dummy.yaml")
+
+         assert locations == []
+
+
+ class TestExportFunctions:
+     """Test export functions."""
+
+     @pytest.fixture
+     def sample_locations(self):
+         """Sample location data for testing."""
+         return [
+             {
+                 "name": "Test Location 1",
+                 "type": "restaurant",
+                 "latitude": 40.7128,
+                 "longitude": -74.0060,
+                 "tags": ["food", "dinner"],
+                 "neighborhood": "Manhattan",
+                 "date_added": "2024-01-01",
+             },
+             {
+                 "name": "Test Location 2",
+                 "type": "cafe",
+                 "latitude": 40.7589,
+                 "longitude": -73.9851,
+                 "tags": ["coffee", "breakfast"],
+                 "neighborhood": "Midtown",
+                 "date_added": "2024-01-02",
+             },
+         ]
+
+     def test_export_to_json(self, sample_locations):
+         """Test JSON export."""
+         with tempfile.NamedTemporaryFile(mode="w", suffix=".json", delete=False) as f:
+             temp_path = f.name
+
+         try:
+             export_to_json(sample_locations, temp_path)
+
+             # Check file was created
+             assert os.path.exists(temp_path)
+
+             # Check content
+             with open(temp_path, "r") as f:
+                 content = f.read()
+                 assert "Test Location 1" in content
+                 assert "Test Location 2" in content
+                 assert "restaurant" in content
+                 assert "cafe" in content
+         finally:
+             os.unlink(temp_path)
+
+     def test_export_to_csv(self, sample_locations):
+         """Test CSV export."""
+         with tempfile.NamedTemporaryFile(mode="w", suffix=".csv", delete=False) as f:
+             temp_path = f.name
+
+         try:
+             export_to_csv(sample_locations, temp_path)
+
+             # Check file was created
+             assert os.path.exists(temp_path)
+
+             # Check content
+             with open(temp_path, "r") as f:
+                 content = f.read()
+                 assert "Test Location 1" in content
+                 assert "Test Location 2" in content
+                 assert "restaurant" in content
+                 assert "cafe" in content
+                 assert "food, dinner" in content
+         finally:
+             os.unlink(temp_path)
+
+     def test_export_to_geojson(self, sample_locations):
+         """Test GeoJSON export."""
+         with tempfile.NamedTemporaryFile(mode="w", suffix=".geojson", delete=False) as f:
+             temp_path = f.name
+
+         try:
+             export_to_geojson(sample_locations, temp_path)
+
+             # Check file was created
+             assert os.path.exists(temp_path)
+
+             # Check content
+             with open(temp_path, "r") as f:
+                 content = f.read()
+                 assert "FeatureCollection" in content
+                 assert "Test Location 1" in content
+                 assert "Test Location 2" in content
+                 assert "Point" in content
+                 assert "40.7128" in content
+                 assert "-74.0060" in content
+         finally:
+             os.unlink(temp_path)
+
+     def test_export_to_kml(self, sample_locations):
+         """Test KML export."""
+         with tempfile.NamedTemporaryFile(mode="w", suffix=".kml", delete=False) as f:
+             temp_path = f.name
+
+         try:
+             export_to_kml(sample_locations, temp_path)
+
+             # Check file was created
+             assert os.path.exists(temp_path)
+
+             # Check content
+             with open(temp_path, "r") as f:
+                 content = f.read()
+                 assert "<?xml" in content
+                 assert "<kml" in content
+                 assert "Test Location 1" in content
+                 assert "Test Location 2" in content
+                 assert "restaurant" in content
+                 assert "cafe" in content
+         finally:
+             os.unlink(temp_path)
+
+     def test_export_to_all_formats(self, sample_locations):
+         """Test export to all formats."""
+         with tempfile.TemporaryDirectory() as temp_dir:
+             base_path = os.path.join(temp_dir, "test_export")
+
+             export_to_all_formats(sample_locations, base_path)
+
+             # Check all files were created
+             expected_files = [
+                 f"{base_path}.json",
+                 f"{base_path}.csv",
+                 f"{base_path}.geojson",
+                 f"{base_path}.kml",
+             ]
+
+             for file_path in expected_files:
+                 assert os.path.exists(file_path), f"File {file_path} was not created"
+
+
+ class TestMapGeneration:
+     """Test map generation functionality."""
+
+     @pytest.fixture
+     def sample_locations(self):
+         """Sample location data for testing."""
+         return [
+             {
+                 "name": "Test Location 1",
+                 "type": "restaurant",
+                 "latitude": 40.7128,
+                 "longitude": -74.0060,
+                 "tags": ["food", "dinner"],
+                 "neighborhood": "Manhattan",
+                 "date_added": "2024-01-01",
+             },
+         ]
+
+     def test_show_locations_grouped_creates_file(self, sample_locations):
+         """Test that map generation creates an HTML file."""
+         with tempfile.NamedTemporaryFile(mode="w", suffix=".html", delete=False) as f:
+             temp_path = f.name
+
+         try:
+             from map_locations.core import show_locations_grouped
+             show_locations_grouped(sample_locations, map_filename=temp_path)
+
+             # Check file was created
+             assert os.path.exists(temp_path)
+
+             # Check it's an HTML file
+             with open(temp_path, "r") as f:
+                 content = f.read()
+                 assert "<!DOCTYPE html>" in content
+                 assert "folium" in content.lower()
+         finally:
+             os.unlink(temp_path)
+
+     def test_show_locations_grouped_empty_locations(self):
+         """Test map generation with empty locations list."""
+         from map_locations.core import show_locations_grouped
+
+         with pytest.raises(ValueError, match="No locations provided"):
+             show_locations_grouped([], map_filename="dummy.html")
```

---

Now let me create a simple example script to demonstrate the package usage:


---

```diff
-
+ #!/usr/bin/env python3
+ """
+ Basic usage example for map_locations package.
+
+ This script demonstrates how to use the map_locations package
+ to load location data, create maps, and export to various formats.
+ """
+
+ import os
+ import sys
+ from pathlib import Path
+
+ # Add the parent directory to the path so we can import map_locations
+ sys.path.insert(0, str(Path(__file__).parent.parent))
+
+ from map_locations import (
+     load_locations_from_yaml,
+     show_locations_grouped,
+     export_to_all_formats,
+ )
+
+
+ def create_sample_data():
+     """Create sample location data for demonstration."""
+     sample_data = {
+         "locations": [
+             {
+                 "name": "Central Park",
+                 "type": "park",
+                 "latitude": 40.7829,
+                 "longitude": -73.9654,
+                 "tags": ["outdoor", "recreation", "nature"],
+                 "neighborhood": "Upper East Side",
+                 "date_added": "2024-01-01",
+                 "date_visited": "2024-01-15",
+             },
+             {
+                 "name": "Times Square",
+                 "type": "landmark",
+                 "latitude": 40.7580,
+                 "longitude": -73.9855,
+                 "tags": ["tourist", "entertainment", "shopping"],
+                 "neighborhood": "Midtown",
+                 "date_added": "2024-01-02",
+                 "date_visited": "2024-01-20",
+             },
+             {
+                 "name": "Brooklyn Bridge",
+                 "type": "bridge",
+                 "latitude": 40.7061,
+                 "longitude": -73.9969,
+                 "tags": ["landmark", "architecture", "views"],
+                 "neighborhood": "Brooklyn",
+                 "date_added": "2024-01-03",
+                 "date_visited": "2024-01-25",
+             },
+             {
+                 "name": "Statue of Liberty",
+                 "type": "monument",
+                 "latitude": 40.6892,
+                 "longitude": -74.0445,
+                 "tags": ["landmark", "history", "tourist"],
+                 "neighborhood": "Lower Manhattan",
+                 "date_added": "2024-01-04",
+                 "date_visited": "2024-01-30",
+             },
+         ]
+     }
+
+     # Create examples directory if it doesn't exist
+     examples_dir = Path(__file__).parent
+     examples_dir.mkdir(exist_ok=True)
+
+     # Save sample data to YAML file
+     import yaml
+     sample_file = examples_dir / "sample_locations.yaml"
+     with open(sample_file, "w") as f:
+         yaml.dump(sample_data, f, default_flow_style=False)
+
+     return str(sample_file)
+
+
+ def main():
+     """Main function demonstrating package usage."""
+     print("üó∫Ô∏è Map Locations Package - Basic Usage Example")
+     print("=" * 50)
+
+     # Create sample data
+     print("üìù Creating sample location data...")
+     sample_file = create_sample_data()
+     print(f"‚úÖ Sample data created: {sample_file}")
+
+     # Load locations
+     print("\nüìÇ Loading locations from YAML file...")
+     locations = load_locations_from_yaml(sample_file)
+     print(f"üìç Loaded {len(locations)} locations")
+
+     # Display location information
+     print("\nüìã Location Details:")
+     for i, location in enumerate(locations, 1):
+         print(f"  {i}. {location['name']} ({location['type']})")
+         print(f"     üìç {location['latitude']}, {location['longitude']}")
+         print(f"     üèòÔ∏è  {location['neighborhood']}")
+         print(f"     üè∑Ô∏è  {', '.join(location['tags'])}")
+         print()
+
+     # Create output directory
+     output_dir = Path(__file__).parent / "output"
+     output_dir.mkdir(exist_ok=True)
+
+     # Create interactive map
+     print("üó∫Ô∏è Creating interactive map...")
+     map_file = output_dir / "sample_map.html"
+     show_locations_grouped(
+         locations,
+         group_by="neighborhood",
+         map_filename=str(map_file),
+     )
+     print(f"‚úÖ Interactive map created: {map_file}")
+
+     # Export to all formats
+     print("\nüì§ Exporting to all formats...")
+     export_base = output_dir / "sample_locations"
+     export_to_all_formats(locations, str(export_base))
+     print(f"‚úÖ All formats exported to: {output_dir}")
+
+     # List exported files
+     print("\nüìÅ Exported files:")
+     for ext in [".json", ".csv", ".geojson", ".kml"]:
+         file_path = export_base.with_suffix(ext)
+         if file_path.exists():
+             print(f"  üìÑ {file_path.name}")
+
+     print(f"\nüéâ Example completed successfully!")
+     print(f"üìÇ Check the '{output_dir}' directory for generated files.")
+     print(f"üåê Open '{map_file}' in your browser to view the interactive map.")
+
+
+ if __name__ == "__main__":
+     main()
```

---

Now let me update the README to include information about the packaging:


---

Read file: README.md

---



---



---



---



---

Now let me add a section about development and testing to the README:


---



---

Now let me test the packaging setup by building the package:


---

Cancelled

---



---
